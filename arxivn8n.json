{
â€œnameâ€: â€œArXiv Academic Clarifying Agentâ€,
â€œnodesâ€: [
{
â€œparametersâ€: {
â€œupdatesâ€: [
â€œmessageâ€
],
â€œadditionalFieldsâ€: {}
},
â€œidâ€: â€œtelegram-triggerâ€,
â€œnameâ€: â€œTelegram Triggerâ€,
â€œtypeâ€: â€œn8n-nodes-base.telegramTriggerâ€,
â€œtypeVersionâ€: 1.2,
â€œpositionâ€: [
220,
300
],
â€œcredentialsâ€: {
â€œtelegramApiâ€: {
â€œidâ€: â€œtelegram_bot_credentialsâ€,
â€œnameâ€: â€œTelegram Bot APIâ€
}
}
},
{
â€œparametersâ€: {
â€œjsCodeâ€: â€œ// Parse Telegram command and manage conversation state\nconst message = $json.message.text || â€˜â€™;\nconst chatId = $json.message.chat.id;\nconst userId = $json.message.from.id;\nconst messageId = $json.message.message_id;\n\n// Create unique conversation key\nconst conversationKey = `conversation_${chatId}`;\n\n// Initialize or retrieve conversation state from static data\nconst staticData = this.getWorkflowStaticData(â€˜globalâ€™);\nif (!staticData.conversations) {\n  staticData.conversations = {};\n}\n\nlet conversation = staticData.conversations[conversationKey] || {\n  state: â€˜idleâ€™,\n  query: â€˜â€™,\n  timeframe: null,\n  specificArea: null,\n  authorPreference: null,\n  lastActivity: Date.now()\n};\n\n// Clean up old conversations (older than 10 minutes)\nObject.keys(staticData.conversations).forEach(key => {\n  if (Date.now() - staticData.conversations[key].lastActivity > 600000) {\n    delete staticData.conversations[key];\n  }\n});\n\n// Handle different message types\nif (message.startsWith(â€™/â€™)) {\n  // New command - reset conversation\n  const parts = message.split(â€™ â€˜);\n  const cmd = parts[0].toLowerCase();\n  \n  switch(cmd) {\n    case â€˜/searchâ€™:\n      const initialQuery = parts.slice(1).join(â€™ â€˜);\n      \n      if (!initialQuery || initialQuery.trim() === â€˜â€™) {\n        return {\n          action: â€˜ask_initial_queryâ€™,\n          chatId: chatId,\n          responseText: â€˜ğŸ” What research topic would you like me to search for?\n\nExamples:\nâ€¢ "quantum computing"\nâ€¢ "transformer neural networks"\nâ€¢ "climate change machine learning"â€™\n        };\n      }\n      \n      // Check if query is too vague (less than 2 words or contains very general terms)\n      const vagueTriggers = [â€˜aiâ€™, â€˜mlâ€™, â€˜quantumâ€™, â€˜deepâ€™, â€˜machineâ€™, â€˜neuralâ€™, â€˜learningâ€™, â€˜computingâ€™, â€˜algorithmâ€™, â€˜dataâ€™];\n      const queryWords = initialQuery.toLowerCase().split(â€™ â€˜);\n      const isVague = queryWords.length < 2 || vagueTriggers.some(trigger => \n        queryWords.includes(trigger) && queryWords.length < 3\n      );\n      \n      if (isVague) {\n        // Start clarification process\n        conversation.state = â€˜clarifying_topicâ€™;\n        conversation.query = initialQuery;\n        conversation.lastActivity = Date.now();\n        staticData.conversations[conversationKey] = conversation;\n        \n        return {\n          action: â€˜clarify_topicâ€™,\n          chatId: chatId,\n          responseText: `ğŸ¤” \"${initialQuery}\" is pretty broad! Let me help you narrow it down:\\n\\n1ï¸âƒ£ Applications (practical uses)\\n2ï¸âƒ£ Theory & fundamentals\\n3ï¸âƒ£ Hardware/implementation\\n4ï¸âƒ£ Specific algorithms/methods\\n5ï¸âƒ£ Something else\\n\\nJust type the number or describe what aspect interests you most!`,\n          conversationState: conversation\n        };\n      } else {\n        // Query seems specific enough, ask about timeframe\n        conversation.state = â€˜clarifying_timeframeâ€™;\n        conversation.query = initialQuery;\n        conversation.lastActivity = Date.now();\n        staticData.conversations[conversationKey] = conversation;\n        \n        return {\n          action: â€˜clarify_timeframeâ€™,\n          chatId: chatId,\n          responseText: `ğŸ“… Great! Searching for \"${initialQuery}\"\\n\\nWhat timeframe are you interested in?\\n\\n1ï¸âƒ£ Last 7 days (bleeding edge)\\n2ï¸âƒ£ Last 30 days (recent)\\n3ï¸âƒ£ Last 3 months (broader view)\\n4ï¸âƒ£ All time (comprehensive)\\n\\nType the number or specify days (e.g., \"14 days\")`,\n          conversationState: conversation\n        };\n      }\n      \n    case â€˜/helpâ€™:\n      return {\n        action: â€˜helpâ€™,\n        chatId: chatId,\n        responseText: â€˜ğŸ¤– **ArXiv Research Assistant**\n\nI help you find and summarize academic papers!\n\n**Commands:**\n/search - Start a research query\n/cancel - Cancel current conversation\n/help - Show this message\n\n**I\â€™ll ask clarifying questions to give you the best results!**â€™\n      };\n      \n    case â€˜/cancelâ€™:\n      delete staticData.conversations[conversationKey];\n      return {\n        action: â€˜cancelâ€™,\n        chatId: chatId,\n        responseText: â€˜âŒ Conversation cancelled. Use /search to start a new query!â€™\n      };\n      \n    default:\n      return {\n        action: â€˜unknown_commandâ€™,\n        chatId: chatId,\n        responseText: â€˜Unknown command. Use /help to see available commands.â€™\n      };\n  }\n} else {\n  // Handle conversation responses\n  if (conversation.state === â€˜idleâ€™) {\n    return {\n      action: â€˜prompt_commandâ€™,\n      chatId: chatId,\n      responseText: â€˜Hi! Use /search to start looking for research papers, or /help for more options.â€™\n    };\n  }\n  \n  // Update last activity\n  conversation.lastActivity = Date.now();\n  \n  if (conversation.state === â€˜clarifying_topicâ€™) {\n    // Handle topic clarification\n    const response = message.toLowerCase();\n    let specificArea = â€˜â€™;\n    \n    if (response.includes(â€˜1â€™) || response.includes(â€˜applicationâ€™)) {\n      specificArea = â€˜applicationsâ€™;\n      conversation.query += â€™ applicationsâ€™;\n    } else if (response.includes(â€˜2â€™) || response.includes(â€˜theoryâ€™) || response.includes(â€˜fundamentalâ€™)) {\n      specificArea = â€˜theoryâ€™;\n      conversation.query += â€™ theory fundamentalsâ€™;\n    } else if (response.includes(â€˜3â€™) || response.includes(â€˜hardwareâ€™) || response.includes(â€˜implementationâ€™)) {\n      specificArea = â€˜hardwareâ€™;\n      conversation.query += â€™ hardware implementationâ€™;\n    } else if (response.includes(â€˜4â€™) || response.includes(â€˜algorithmâ€™) || response.includes(â€˜methodâ€™)) {\n      specificArea = â€˜algorithmsâ€™;\n      conversation.query += â€™ algorithms methodsâ€™;\n    } else {\n      // User provided custom specification\n      specificArea = â€˜customâ€™;\n      conversation.query += â€™ â€™ + message;\n    }\n    \n    conversation.specificArea = specificArea;\n    conversation.state = â€˜clarifying_timeframeâ€™;\n    staticData.conversations[conversationKey] = conversation;\n    \n    return {\n      action: â€˜clarify_timeframeâ€™,\n      chatId: chatId,\n      responseText: `ğŸ“… Perfect! Now searching for \"${conversation.query}\"\\n\\nWhat timeframe interests you?\\n\\n1ï¸âƒ£ Last 7 days (bleeding edge)\\n2ï¸âƒ£ Last 30 days (recent)\\n3ï¸âƒ£ Last 3 months (broader view)\\n4ï¸âƒ£ All time (comprehensive)\\n\\nType the number or specify days (e.g., \"14 days\")`,\n      conversationState: conversation\n    };\n    \n  } else if (conversation.state === â€˜clarifying_timeframeâ€™) {\n    // Handle timeframe clarification\n    const response = message.toLowerCase();\n    let timeframe = â€˜recentâ€™;\n    \n    if (response.includes(â€˜1â€™) || response.includes(â€˜7â€™)) {\n      timeframe = 7;\n    } else if (response.includes(â€˜2â€™) || response.includes(â€˜30â€™)) {\n      timeframe = 30;\n    } else if (response.includes(â€˜3â€™) || response.includes(â€˜90â€™) || response.includes(â€˜monthâ€™)) {\n      timeframe = 90;\n    } else if (response.includes(â€˜4â€™) || response.includes(â€˜allâ€™)) {\n      timeframe = â€˜allâ€™;\n    } else {\n      // Try to extract number of days\n      const dayMatch = response.match(/(\d+)\s*days?/);\n      if (dayMatch) {\n        timeframe = parseInt(dayMatch[1]);\n      }\n    }\n    \n    conversation.timeframe = timeframe;\n    conversation.state = â€˜clarifying_authorsâ€™;\n    staticData.conversations[conversationKey] = conversation;\n    \n    return {\n      action: â€˜clarify_authorsâ€™,\n      chatId: chatId,\n      responseText: `ğŸ‘¥ Almost ready! Any author preferences?\\n\\n1ï¸âƒ£ No preference (show me everything)\\n2ï¸âƒ£ Well-known researchers only\\n3ï¸âƒ£ Specific author (tell me who)\\n4ï¸âƒ£ Exclude specific authors\\n\\nType the number or author name`,\n      conversationState: conversation\n    };\n    \n  } else if (conversation.state === â€˜clarifying_authorsâ€™) {\n    // Handle author preferences\n    const response = message.toLowerCase();\n    let authorPreference = â€˜noneâ€™;\n    \n    if (response.includes(â€˜1â€™) || response.includes(â€˜no preferenceâ€™)) {\n      authorPreference = â€˜noneâ€™;\n    } else if (response.includes(â€˜2â€™) || response.includes(â€˜well-knownâ€™) || response.includes(â€˜famousâ€™)) {\n      authorPreference = â€˜well-knownâ€™;\n    } else if (response.includes(â€˜3â€™) || response.includes(â€˜specificâ€™)) {\n      authorPreference = â€˜include:â€™ + message;\n    } else if (response.includes(â€˜4â€™) || response.includes(â€˜excludeâ€™)) {\n      authorPreference = â€˜exclude:â€™ + message;\n    } else {\n      // Assume they mentioned an author name\n      authorPreference = â€˜include:â€™ + message;\n    }\n    \n    conversation.authorPreference = authorPreference;\n    conversation.state = â€˜ready_to_searchâ€™;\n    staticData.conversations[conversationKey] = conversation;\n    \n    const timeframeText = typeof conversation.timeframe === â€˜numberâ€™ \n      ? `last ${conversation.timeframe} days` \n      : conversation.timeframe === â€˜allâ€™ ? â€˜all timeâ€™ : â€˜recent papersâ€™;\n    \n    return {\n      action: â€˜execute_searchâ€™,\n      chatId: chatId,\n      responseText: `ğŸš€ Perfect! Searching now...\\n\\n**Query:** ${conversation.query}\\n**Timeframe:** ${timeframeText}\\n**Authors:** ${authorPreference}\\n\\nI'll send you an email report shortly!`,\n      conversationState: conversation,\n      finalQuery: conversation.query,\n      timeframe: conversation.timeframe,\n      authorPreference: conversation.authorPreference\n    };\n  }\n  \n  // Clean up conversation after search\n  if (conversation.state === â€˜ready_to_searchâ€™) {\n    delete staticData.conversations[conversationKey];\n  }\n}\n\nreturn {\n  action: â€˜errorâ€™,\n  chatId: chatId,\n  responseText: â€˜Something went wrong. Use /search to start over!â€™\n};â€
},
â€œidâ€: â€œconversation-managerâ€,
â€œnameâ€: â€œConversation Managerâ€,
â€œtypeâ€: â€œn8n-nodes-base.codeâ€,
â€œtypeVersionâ€: 2,
â€œpositionâ€: [
440,
300
]
},
{
â€œparametersâ€: {
â€œconditionsâ€: {
â€œoptionsâ€: {
â€œcaseSensitiveâ€: true,
â€œleftValueâ€: â€œâ€,
â€œtypeValidationâ€: â€œstrictâ€
},
â€œconditionsâ€: [
{
â€œidâ€: â€œexecute-search-conditionâ€,
â€œleftValueâ€: â€œ={{ $json.action }}â€,
â€œrightValueâ€: â€œexecute_searchâ€,
â€œoperatorâ€: {
â€œtypeâ€: â€œstringâ€,
â€œoperationâ€: â€œequalsâ€
}
}
],
â€œcombinatorâ€: â€œandâ€
},
â€œoptionsâ€: {}
},
â€œidâ€: â€œaction-routerâ€,
â€œnameâ€: â€œAction Routerâ€,
â€œtypeâ€: â€œn8n-nodes-base.ifâ€,
â€œtypeVersionâ€: 2,
â€œpositionâ€: [
660,
300
]
},
{
â€œparametersâ€: {
â€œresourceâ€: â€œmessageâ€,
â€œoperationâ€: â€œsendMessageâ€,
â€œchatIdâ€: â€œ={{ $json.chatId }}â€,
â€œtextâ€: â€œ={{ $json.responseText }}â€,
â€œadditionalFieldsâ€: {
â€œparse_modeâ€: â€œMarkdownâ€
}
},
â€œidâ€: â€œsend-clarificationâ€,
â€œnameâ€: â€œSend Clarificationâ€,
â€œtypeâ€: â€œn8n-nodes-base.telegramâ€,
â€œtypeVersionâ€: 1.2,
â€œpositionâ€: [
880,
200
],
â€œcredentialsâ€: {
â€œtelegramApiâ€: {
â€œidâ€: â€œtelegram_bot_credentialsâ€,
â€œnameâ€: â€œTelegram Bot APIâ€
}
}
},
{
â€œparametersâ€: {
â€œurlâ€: â€œhttp://export.arxiv.org/api/queryâ€,
â€œoptionsâ€: {
â€œqueryParametersâ€: {
â€œparametersâ€: [
{
â€œnameâ€: â€œsearch_queryâ€,
â€œvalueâ€: â€œ={{ â€˜all:â€™ + $json.finalQuery }}â€
},
{
â€œnameâ€: â€œstartâ€,
â€œvalueâ€: â€œ0â€
},
{
â€œnameâ€: â€œmax_resultsâ€,
â€œvalueâ€: â€œ15â€
},
{
â€œnameâ€: â€œsortByâ€,
â€œvalueâ€: â€œsubmittedDateâ€
},
{
â€œnameâ€: â€œsortOrderâ€,
â€œvalueâ€: â€œdescendingâ€
}
]
}
}
},
â€œidâ€: â€œarxiv-searchâ€,
â€œnameâ€: â€œArXiv API Searchâ€,
â€œtypeâ€: â€œn8n-nodes-base.httpRequestâ€,
â€œtypeVersionâ€: 4.2,
â€œpositionâ€: [
880,
400
]
},
{
â€œparametersâ€: {
â€œjsCodeâ€: â€œ// Parse ArXiv XML response with enhanced filtering based on clarifications\nconst xmlData = $json.data || $json;\nconst searchParams = $input.first().json;\nlet papers = [];\n\n// Basic XML parsing for ArXiv feed\nif (typeof xmlData === â€˜stringâ€™) {\n  const entryRegex = /<entry>(.*?)<\/entry>/gs;\n  const titleRegex = /<title>(.*?)<\/title>/s;\n  const summaryRegex = /<summary>(.*?)<\/summary>/s;\n  const authorRegex = /<author><name>(.*?)<\/name><\/author>/g;\n  const publishedRegex = /<published>(.*?)<\/published>/s;\n  const linkRegex = /<id>(.*?)<\/id>/s;\n  const categoryRegex = /<category term="(.*?)".*?>/g;\n  \n  let match;\n  let entryCount = 0;\n  \n  while ((match = entryRegex.exec(xmlData)) !== null && entryCount < 15) {\n    const entry = match[1];\n    \n    const titleMatch = titleRegex.exec(entry);\n    const summaryMatch = summaryRegex.exec(entry);\n    const publishedMatch = publishedRegex.exec(entry);\n    const linkMatch = linkRegex.exec(entry);\n    \n    // Extract all authors\n    const authors = [];\n    let authorMatch;\n    const authorRegexForEntry = /<author><name>(.*?)<\/name><\/author>/g;\n    while ((authorMatch = authorRegexForEntry.exec(entry)) !== null) {\n      authors.push(authorMatch[1]);\n    }\n    \n    // Extract categories\n    const categories = [];\n    let categoryMatch;\n    const categoryRegexForEntry = /<category term="(.*?)".*?>/g;\n    while ((categoryMatch = categoryRegexForEntry.exec(entry)) !== null) {\n      categories.push(categoryMatch[1]);\n    }\n    \n    if (titleMatch && summaryMatch) {\n      // Enhanced relevance scoring with clarification context\n      const query = searchParams.finalQuery.toLowerCase();\n      const title = titleMatch[1].toLowerCase();\n      const abstract = summaryMatch[1].toLowerCase();\n      const authorString = authors.join(â€™ â€˜).toLowerCase();\n      \n      let relevanceScore = 0;\n      const queryWords = query.split(â€™ â€˜);\n      \n      // Base scoring\n      queryWords.forEach(word => {\n        if (word.length > 3) {\n          if (title.includes(word)) relevanceScore += 3;\n          if (abstract.includes(word)) relevanceScore += 1;\n        }\n      });\n      \n      // Bonus scoring based on specific area\n      const specificArea = searchParams.conversationState?.specificArea;\n      if (specificArea === â€˜applicationsâ€™) {\n        if (title.includes(â€˜applicationâ€™) || abstract.includes(â€˜practicalâ€™) || abstract.includes(â€˜implementationâ€™)) {\n          relevanceScore += 2;\n        }\n      } else if (specificArea === â€˜theoryâ€™) {\n        if (title.includes(â€˜theoryâ€™) || abstract.includes(â€˜theoreticalâ€™) || abstract.includes(â€˜proofâ€™)) {\n          relevanceScore += 2;\n        }\n      } else if (specificArea === â€˜hardwareâ€™) {\n        if (title.includes(â€˜hardwareâ€™) || abstract.includes(â€˜chipâ€™) || abstract.includes(â€˜implementationâ€™)) {\n          relevanceScore += 2;\n        }\n      }\n      \n      // Author preference filtering\n      let includeByAuthor = true;\n      const authorPref = searchParams.authorPreference;\n      if (authorPref && authorPref !== â€˜noneâ€™) {\n        if (authorPref.startsWith(â€˜include:â€™)) {\n          const targetAuthor = authorPref.replace(â€˜include:â€™, â€˜â€™).toLowerCase().trim();\n          includeByAuthor = authorString.includes(targetAuthor);\n          if (includeByAuthor) relevanceScore += 3; // Bonus for requested author\n        } else if (authorPref.startsWith(â€˜exclude:â€™)) {\n          const excludeAuthor = authorPref.replace(â€˜exclude:â€™, â€˜â€™).toLowerCase().trim();\n          includeByAuthor = !authorString.includes(excludeAuthor);\n        } else if (authorPref === â€˜well-knownâ€™) {\n          // Simple heuristic: well-known authors often have many papers\n          // In a real implementation, youâ€™d check against a database of notable researchers\n          const authorCount = authors.length;\n          if (authorCount >= 3) relevanceScore += 1; // Multi-author papers often from established groups\n        }\n      }\n      \n      // Timeframe filtering\n      const publishedDate = new Date(publishedMatch ? publishedMatch[1] : Date.now());\n      const now = new Date();\n      const timeframe = searchParams.timeframe;\n      \n      let includeByDate = true;\n      if (typeof timeframe === â€˜numberâ€™) {\n        const daysAgo = new Date(now.getTime() - (timeframe * 24 * 60 * 60 * 1000));\n        includeByDate = publishedDate >= daysAgo;\n      }\n      \n      if (includeByDate && includeByAuthor && relevanceScore > 0) {\n        papers.push({\n          title: titleMatch[1].replace(/\s+/g, â€™ â€˜).trim(),\n          authors: authors.join(â€™, â€˜),\n          abstract: summaryMatch[1].replace(/\s+/g, â€™ â€˜).trim().substring(0, 500) + â€˜â€¦â€™,\n          published: publishedMatch ? new Date(publishedMatch[1]).toLocaleDateString() : â€˜Unknownâ€™,\n          url: linkMatch ? linkMatch[1] : â€˜â€™,\n          categories: categories.join(â€™, â€˜),\n          relevanceScore: relevanceScore,\n          matchedCriteria: {\n            timeframe: includeByDate,\n            author: includeByAuthor,\n            specificArea: specificArea\n          }\n        });\n      }\n    }\n    entryCount++;\n  }\n  \n  // Sort by relevance score and take top results\n  papers.sort((a, b) => b.relevanceScore - a.relevanceScore);\n  papers = papers.slice(0, 8); // Top 8 most relevant\n}\n\nreturn {\n  papers: papers,\n  totalFound: papers.length,\n  searchParams: searchParams,\n  chatId: searchParams.chatId\n};â€
},
â€œidâ€: â€œenhanced-parserâ€,
â€œnameâ€: â€œEnhanced ArXiv Parserâ€,
â€œtypeâ€: â€œn8n-nodes-base.codeâ€,
â€œtypeVersionâ€: 2,
â€œpositionâ€: [
1100,
400
]
},
{
â€œparametersâ€: {
â€œmodelâ€: â€œgpt-4o-miniâ€,
â€œoptionsâ€: {
â€œtemperatureâ€: 0.3,
â€œmaxTokensâ€: 1500
},
â€œmessagesâ€: {
â€œvaluesâ€: [
{
â€œroleâ€: â€œsystemâ€,
â€œcontentâ€: â€œYou are an expert academic research assistant. Create insightful, personalized summaries based on the userâ€™s specific research interests and clarifications.\n\nFor each paper, provide:\n1. **Key Innovation**: Whatâ€™s new or significant about this work?\n2. **Practical Value**: How does this advance the field or solve real problems?\n3. **Relevance**: Why this matters for the userâ€™s specific query\n4. **Quality Indicators**: Citation potential, methodology strength, or novelty\n\nFormat as a professional research brief suitable for busy academics. Use clear headers and concise language.â€
},
{
â€œroleâ€: â€œuserâ€,
â€œcontentâ€: â€œ**Research Query Analysis:**\n- Original Query: {{ $json.searchParams.finalQuery }}\n- Specific Focus: {{ $json.searchParams.conversationState?.specificArea || â€˜Generalâ€™ }}\n- Timeframe: {{ typeof $json.searchParams.timeframe === â€˜numberâ€™ ? $json.searchParams.timeframe + â€™ daysâ€™ : $json.searchParams.timeframe }}\n- Author Preference: {{ $json.searchParams.authorPreference || â€˜Noneâ€™ }}\n\n**Found {{ $json.totalFound }} Relevant Papers:**\n\n{{ $json.papers.map((paper, index) => `**Paper ${index + 1}: ${paper.title}**\n- Authors: ${paper.authors}\n- Published: ${paper.published}\n- Categories: ${paper.categories}\n- Relevance Score: ${paper.relevanceScore}/10\n- Abstract: ${paper.abstract}\n- URL: ${paper.url}\n\n`).join(â€™â€™) }}\n\n**Task:** Create a structured research brief that addresses the userâ€™s specific interests and explains why each paper was selected based on their clarifications.â€
}
]
}
},
â€œidâ€: â€œcontextual-summarizerâ€,
â€œnameâ€: â€œContextual AI Summarizerâ€,
â€œtypeâ€: â€œn8n-nodes-langchain.openaiâ€,
â€œtypeVersionâ€: 1.4,
â€œpositionâ€: [
1320,
400
],
â€œcredentialsâ€: {
â€œopenAiApiâ€: {
â€œidâ€: â€œopenai_credentialsâ€,
â€œnameâ€: â€œOpenAI APIâ€
}
}
},
{
â€œparametersâ€: {
â€œjsCodeâ€: â€œ// Format personalized email with conversation context\nconst aiSummary = $json.content[0].text;\nconst data = $input.first().json;\nconst searchParams = data.searchParams;\n\n// Build personalized subject and context\nconst specificArea = searchParams.conversationState?.specificArea || â€˜generalâ€™;\nconst timeframeText = typeof searchParams.timeframe === â€˜numberâ€™ \n  ? `last ${searchParams.timeframe} days` \n  : searchParams.timeframe === â€˜allâ€™ ? â€˜all timeâ€™ : â€˜recentâ€™;\n\nconst subject = `ğŸ¯ ArXiv Research Brief: ${searchParams.finalQuery} (${data.totalFound} papers, ${specificArea} focus)`;\n\n// Create detailed email body\nconst emailBody = `# ğŸ”¬ Personalized ArXiv Research Brief\n\n## Your Research Query\n**Search Terms:** ${searchParams.finalQuery}  \n**Focus Area:** ${specificArea.charAt(0).toUpperCase() + specificArea.slice(1)} research  \n**Time Range:** ${timeframeText}  \n**Author Filter:** ${searchParams.authorPreference === 'none' ? 'No preference' : searchParams.authorPreference}  \n**Papers Found:** ${data.totalFound} relevant matches  \n\n---\n\n## ğŸ“Š Research Intelligence Summary\n\n${aiSummary}\n\n---\n\n## ğŸ“ˆ Search Quality Metrics\n- **Relevance Filtering:** Advanced scoring based on your clarifications\n- **Time Sensitivity:** ${timeframeText === 'last 7 days' ? 'ğŸ”¥ Cutting-edge' : timeframeText === 'last 30 days' ? 'âš¡ Recent developments' : 'ğŸ“š Comprehensive view'}\n- **Focus Accuracy:** Specialized for ${specificArea} applications\n- **Author Matching:** ${searchParams.authorPreference !== 'none' ? 'âœ… Custom filtered' : 'ğŸŒ Broad coverage'}\n\n---\n\n## ğŸš€ Next Steps Suggestions\n1. **Dive Deeper:** Focus on papers with highest relevance scores (8+)\n2. **Cross-Reference:** Check citation networks between selected papers\n3. **Stay Updated:** Run this search weekly for emerging developments\n4. **Expand Search:** Try related terms like [suggest 2-3 related queries]\n\n---\n\n*ğŸ“§ This personalized research brief was generated by your ArXiv Academic Agent*  \n*ğŸ¤– Powered by conversational AI clarification and contextual analysis*  \n*â° Generated: ${new Date().toLocaleString()}*\n\n**ğŸ”„ Want different results?** Simply chat with your bot using different clarifications!`;\n\nreturn {\n  emailSubject: subject,\n  emailBody: emailBody,\n  htmlEmailBody: emailBody\n    .replace(/\n/g, â€˜<br>â€™)\n    .replace(/\*\*(.*?)\*\*/g, â€˜<strong>$1</strong>â€™)\n    .replace(/\*(.*?)\*/g, â€˜<em>$1</em>â€™)\n    .replace(/^# (.*?)$/gm, â€˜<h1>$1</h1>â€™)\n    .replace(/^## (.*?)$/gm, â€˜<h2>$1</h2>â€™)\n    .replace(/^### (.*?)$/gm, â€˜<h3>$1</h3>â€™)\n    .replace(/ğŸ”¥|âš¡|ğŸ“š|âœ…|ğŸŒ|ğŸ“Š|ğŸ”¬|ğŸ¯|ğŸ“ˆ|ğŸš€|ğŸ“§|ğŸ¤–|â°|ğŸ”„/g, â€˜â€™),\n  chatId: data.chatId,\n  papersFound: data.totalFound,\n  searchContext: `${searchParams.finalQuery} (${specificArea} focus)`\n};â€
},
â€œidâ€: â€œpersonalized-formatterâ€,
â€œnameâ€: â€œPersonalized Email Formatterâ€,
â€œtypeâ€: â€œn8n-nodes-base.codeâ€,
â€œtypeVersionâ€: 2,
â€œpositionâ€: [
1540,
400
]
},
{
â€œparametersâ€: {
â€œresourceâ€: â€œmessageâ€,
â€œoperationâ€: â€œsendâ€,
â€œtoâ€: â€œyour-email@university.eduâ€,
â€œsubjectâ€: â€œ={{ $json.emailSubject }}â€,
â€œemailTypeâ€: â€œhtmlâ€,
â€œmessageâ€: â€œ={{ $json.htmlEmailBody }}â€,
â€œoptionsâ€: {
â€œappendAttributionâ€: false
}
},
â€œidâ€: â€œsend-personalized-emailâ€,
â€œnameâ€: â€œSend Personalized Emailâ€,
â€œtypeâ€: â€œn8n-nodes-base.gmailâ€,
â€œtypeVersionâ€: 2.1,
â€œpositionâ€: [
1760,
400
],
â€œcredentialsâ€: {
â€œgmailOAuth2â€: {
â€œidâ€: â€œgmail_credentialsâ€,
â€œnameâ€: â€œGmail OAuth2â€
}
}
},
{
â€œparametersâ€: {
â€œresourceâ€: â€œmessageâ€,
â€œoperationâ€: â€œsendMessageâ€,
â€œchatIdâ€: â€œ={{ $json.chatId }}â€,
â€œtextâ€: â€œâœ… **Research brief delivered!**\n\nğŸ“Š Found {{ $json.papersFound }} papers for "{{ $json.searchContext }}"\nğŸ“§ Personalized analysis sent to your email\nğŸ¯ Filtered based on your specific clarifications\n\n*Use /search again anytime for new queries!*â€,
â€œadditionalFieldsâ€: {
â€œparse_modeâ€: â€œMarkdownâ€
}
},
â€œidâ€: â€œfinal-confirmationâ€,
â€œnameâ€: â€œSend Success Confirmationâ€,
â€œtypeâ€: â€œn8n-nodes-base.telegramâ€,
â€œtypeVersionâ€: 1.2,
â€œpositionâ€: [
1980,
400
],
â€œcredentialsâ€: {
â€œtelegramApiâ€: {
â€œidâ€: â€œtelegram_bot_credentialsâ€,
â€œnameâ€: â€œTelegram Bot APIâ€
}
}
}
],
â€œconnectionsâ€: {
â€œTelegram Triggerâ€: {
â€œmainâ€: [
[
{
â€œnodeâ€: â€œConversation Managerâ€,
â€œtypeâ€: â€œmainâ€,
â€œindexâ€: 0
}
]
]
},
â€œConversation Managerâ€: {
â€œmainâ€: [
[
{
â€œnodeâ€: â€œAction Routerâ€,
â€œtypeâ€: â€œmainâ€,
â€œindexâ€: 0
}
]
]
},
â€œAction Routerâ€: {
â€œmainâ€: [
[
{
â€œnodeâ€: â€œArXiv API Searchâ€,
â€œtypeâ€: â€œmainâ€,
â€œindexâ€: 0
}
],
[
{
â€œnodeâ€: â€œSend Clarificationâ€,
â€œtypeâ€: â€œmainâ€,
â€œindexâ€: 0
}
]
]
},
â€œArXiv API Searchâ€: {
â€œmainâ€: [
[
{
â€œnodeâ€: â€œEnhanced ArXiv Parserâ€,
â€œtypeâ€: â€œmainâ€,
â€œindexâ€: 0
}
]
]
},
â€œEnhanced ArXiv Parserâ€: {
â€œmainâ€: [
[
{
â€œnodeâ€: â€œContextual AI Summarizerâ€,
â€œtypeâ€: â€œmainâ€,
â€œindexâ€: 0
}
]
]
},
â€œContextual AI Summarizerâ€: {
â€œmainâ€: [
[
{
â€œnodeâ€: â€œPersonalized Email Formatterâ€,
â€œtypeâ€: â€œmainâ€,
â€œindexâ€: 0
}
]
]
},
â€œPersonalized Email Formatterâ€: {
â€œmainâ€: [
[
{
â€œnodeâ€: â€œSend Personalized Emailâ€,
â€œtypeâ€: â€œmainâ€,
â€œindexâ€: 0
}
]
]
},
â€œSend Personalized Emailâ€: {
â€œmainâ€: [
[
{
â€œnodeâ€: â€œSend Success Confirmationâ€,
â€œtypeâ€: â€œmainâ€,
â€œindexâ€: 0
}
]
]
}
},
â€œpinDataâ€: {},
â€œsettingsâ€: {
â€œexecutionOrderâ€: â€œv1â€
},
â€œstaticDataâ€: {},
â€œtagsâ€: [],
â€œtriggerCountâ€: 0,
â€œupdatedAtâ€: â€œ2025-01-20T12:00:00.000Zâ€,
â€œversionIdâ€: â€œ2â€
}